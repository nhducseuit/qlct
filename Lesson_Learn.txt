
# Progress: sprint-5.md

## API Payload Consistency & Layered Data Contracts (Sprint 8+)

### Issue: Unwanted Field in API Payload
- A persistent bug caused the `familyId` field to be sent in the POST body for new categories, even though the UI and dialog code explicitly excluded it.
- Root cause: The frontend API service (`categoryApiService.ts`) forcibly added `familyId` to the POST body, regardless of the dialog's payload, due to `{ ...categoryData, familyId }` in the service function.
- The store always passed `familyId` as a separate argument, so the service layer always injected it into the body.

### Resolution
- The fix was to remove `familyId` from the POST body in the API service, sending only the allowed fields from the dialog/component.
- This aligned the frontend contract with the backend's expectations and eliminated the error.

### Lessons Learned (Technical)

1. **Respect Data Contracts at Each Layer:** UI, store, and API service must all agree on the payload shape. Never inject or mutate fields in the service layer unless explicitly required by the backend contract.
2. **Centralize Payload Shaping:** The component or store should be the single source of truth for what is sent to the backend. The API service should only forward, not transform, unless absolutely necessary.
3. **Trace the Data Flow End-to-End:** When a field appears unexpectedly in the backend, check every layer (component, store, service) for places it might be added or mutated.
4. **Defensive Programming:** Add final defensive checks (e.g., deleting unwanted fields) before sending data, but the best solution is to avoid adding them in the first place.
5. **Test the Actual Network Payload:** Use browser dev tools or logging to inspect the real request body, not just the code.

---

## Sprint 5–7: Person Breakdown Report, Access Control, and Robust State Management (2025-07-09)

### Feature Implementation & Debugging
- Implemented the Person Breakdown report with strict backend access control: only the user's own family can view the report, enforced at both controller and service layers.
- Refactored frontend logic to use a single `<template>` and `<script setup>` in `ReportsPage.vue`, with a computed property (`isUserFamily`) controlling feature visibility.
- Fixed all TypeScript, ESLint, and prop type errors, and resolved malformed template/script block issues.
- Validated that the Person Breakdown report is only shown for the user's own family, never for families the user does not have full access to.

### Lessons Learned (Technical)
1. **Strict Backend Access Control:** Always source sensitive IDs (e.g., `familyId`, `userId`) from the authenticated session, never from client input. This prevents privilege escalation and data leaks. See `.github/instructions/general.instructions` for the permanent directive.
2. **Frontend Feature Visibility:** Use robust computed properties to control feature visibility based on user context, not just route or param checks.
3. **Vue SFC Hygiene:** Avoid duplicate or malformed `<template>`/`<script>` blocks. Use a single `<template>` and `<script setup>` for maintainability and to prevent parsing errors.
4. **Contract Discipline:** Keep frontend models, stores, and API services in sync with backend DTOs. Validate all changes with TypeScript and runtime checks.
5. **State Management:** Use Pinia stores for all shared state, and ensure all state transitions are robust and type-safe.
6. **Documentation:** Document root causes, solutions, and impacts for all bugs and features. Update `Lesson_Learn.txt` and `technical-highlights.md` after each sprint.

---

This sprint reinforced the importance of access control, contract discipline, and documentation for maintainable, secure, and robust multi-user applications.

### Lessons Learned (Process)
1. **Root Cause Analysis:** When a bug persists despite apparent fixes, always check for hidden or duplicated logic in lower layers (services, stores).
2. **Document Data Contracts:** Keep a clear record of what each API expects and what each layer is responsible for.
3. **Review Service Layer Logic:** Service functions should be as thin as possible unless transformation is required by backend design.

## Docker & Containerization:
1.  **Dockerfile Best Practices:**
    *   Pay close attention to `Dockerfile` syntax. Inline comments can sometimes cause parsing issues; prefer comments on their own lines.
    *   The order of `COPY` and `RUN` commands significantly impacts build caching and the final image state. Ensure dependencies (like `prisma/schema.prisma`) are copied *before* `npm install` if postinstall scripts (like `prisma generate`) rely on them.
    *   Multi-stage builds are effective for keeping production images lean by separating build-time dependencies from runtime dependencies.
2.  **Dependency Management in Docker:**
    *   `npm install --only=production` in the final Docker stage is crucial for smaller images but means any runtime-required packages *must* be in `dependencies`, not `devDependencies` (e.g., `@nestjs/swagger`).
3.  **Prisma & Docker:**
    *   `binaryTargets` in `schema.prisma` is essential for cross-platform compatibility (e.g., developing on Windows, deploying on Linux/Alpine). Always include the target runtime (like `linux-musl-openssl-3.0.x` for Alpine).
    *   Ensure `prisma generate` runs within the final image's context, typically via `@prisma/client`'s `postinstall` script, which requires the `schema.prisma` to be present.
4.  **Database Migrations in Docker:**
    *   Database migrations (`npx prisma migrate deploy`) must be explicitly run as part of the container's startup command or entrypoint script in `docker-compose.yml` to ensure the database schema is up-to-date before the application starts.
5.  **Debugging Docker Builds & Runtime:**
    *   Use `docker-compose logs -f <service>` extensively.
    *   For build issues, add `RUN echo "..." && ls -R ...` commands in the `Dockerfile` to inspect the filesystem at various build stages. Invalidate cache for these steps by making minor changes to the `RUN` command.
    *   If a container is crash-looping, temporarily change its `CMD` in the `Dockerfile` (or `command` in `docker-compose.yml`) to something like `sh -c "tail -f /dev/null"` to keep it running for inspection via `docker exec -it <container_name> sh`.

## Backend (NestJS, Prisma, TypeScript):
1.  **TypeScript Path Aliases:**
    *   Path aliases defined in `tsconfig.json` (`paths` and `baseUrl`) are for compile-time.
    *   For runtime resolution in Node.js (especially after compilation to JS), `tsconfig-paths` is necessary.
    *   A separate `tsconfig.prod.json` (or similar) with `baseUrl` pointing to the compiled output directory (e.g., `./dist`) is often required for `tsconfig-paths` to work correctly in production/Docker. `TS_NODE_PROJECT` environment variable should point to this file.
2.  **CORS Configuration:**
    *   Backend (NestJS `app.enableCors()` and `WebSocketGateway` options) must be configured to allow requests from the frontend's origin, including different ports and LAN IPs.
3.  **Environment Variables:**
    *   Use environment variables consistently for configuration (database URLs, frontend URLs, ports, `NODE_ENV`). `docker-compose.yml` is a good place to set these for services.
4.  **WebSocket User Scoping:**
    *   Join clients to user-specific rooms (e.g., based on `userId`) in the `WebSocketGateway` to ensure targeted real-time updates.

## Frontend (Quasar, Pinia, Vite):
1.  **API Base URL Configuration:**
    *   The `VITE_API_BASE_URL` (or similar) used during the frontend build must point to the URL the *browser* will use to access the backend (e.g., `http://<host_lan_ip>:<backend_port>`), not the Docker internal service name.
2.  **State Management & Real-time Updates:**
    *   Pinia stores are effective for managing application state and centralizing API calls.
    *   WebSocket event handlers in stores should update the local state, triggering reactivity in components.
    *   Ensure socket connections and listeners are properly established upon user authentication and cleaned up on logout or component unmount to prevent memory leaks or stale listeners.
3.  **Axios Interceptors:**
    *   Request interceptors are useful for attaching auth tokens.
    *   Response interceptors can handle global errors like 401 Unauthorized (e.g., triggering logout).
4.  **Dev Mode vs. Production Mode:**
    *   Be mindful of how `import.meta.env.DEV` and custom build arguments (like `VITE_FORCE_DEV_USER`) affect application behavior, especially for authentication and API URLs.

## Networking & Docker Compose:
1.  **Service Discovery vs. Host Access:**
    *   Containers on the same Docker Compose network can reach each other using service names (e.g., `backend` can reach `db` at `db:5432`).
    *   The browser (on the host or LAN) accesses services via `localhost:<exposed_port>` or `<host_ip>:<exposed_port>`.
2.  **`depends_on` with `condition: service_healthy`:**
    *   Crucial for ensuring services like the database are ready before dependent services (like the backend) start.

## General Development & Debugging:
1.  **Iterative Problem Solving:** Break down complex issues. The "module not found" errors were tackled one by one, revealing subsequent issues.
2.  **Clear Error Messages:** Pay close attention to error messages. Prisma, NestJS, and Docker often provide very specific clues.
3.  **Version Control:** (Implicit) Regular commits would have been invaluable for rolling back to a stable state if a change introduced too many problems.
4.  **Consistency:** Ensure consistency between DTOs (backend), API service payloads (frontend), and database models/schemas.

## Data Model & State Management Consistency
1.  **Single Source of Truth for IDs:** A seemingly simple display bug (showing a UUID for a name) revealed a systemic data integrity issue. The `payer` field was ambiguously used for both `personId` and `membershipId` across different parts of the application. **Lesson:** Ensure critical identifiers have a single, consistent meaning and type across the entire stack (UI form -> state store -> API payload -> backend service -> database).
2.  **Centralize Data Transformation:** The fix required converting the UI's `membershipId` to the backend's required `personId`. The most robust place for this transformation was not in the component, but in the central state management layer (`transactionStore.ts`). **Lesson:** Centralize data mapping and transformation logic in stores or services to prevent inconsistencies and make the code easier to maintain and debug.
3.  **Regressions Reveal Deeper Issues:** When an initial fix for the `payer` display caused a regression where the `category` also started showing as a UUID, it indicated the problem wasn't just about the `payer` field. It was a flaw in the entire `updateTransaction` data flow. **Lesson:** Pay close attention to regressions; they often point to a more fundamental problem than the one you initially tried to solve.

## Modular Seeder Debugging & Data Integrity (Sprint 7+)

### How much effort could have been saved?
- If the solution (unique key-based mapping, schema alignment, defensive checks, and modular orchestration) had been defined and enforced from the start, we could have saved at least 70-80% of the debugging and rework time.
- Most errors (key mismatches, undefined references, Prisma validation errors) were preventable with clear contracts and up-front schema/data alignment.
- Early, robust logging and defensive programming would have reduced the time spent on root cause analysis.
- A single source of truth for keys and IDs, and validating all seed data before running, would have prevented cascading failures.

### Lessons Learned (Technical)
1. **Define and enforce unique keys** for all entities (categories, memberships, etc.) in both schema and seed data from the beginning.
2. **Align schema and seeders early:** Run migrations and update the database before writing or running seeders that depend on new fields.
3. **Centralize mapping logic:** Build all lookups (e.g., categoryMap, membershipMap) by key, not by id or array index.
4. **Add robust logging and error handling** to all seeders and orchestrators. Log missing keys, undefined references, and data mismatches.
5. **Validate all foreign key references** before using them in upserts. Fail fast and log context if a key is missing.
6. **Test each seeder in isolation** before integrating into the main orchestrator. Use log files to capture runtime state and error context.
7. **Iterate and test frequently,** running the seed process after each change to catch issues early.

### Lessons Learned (Team & Process)
1. **Document contracts and expectations** for all seeders and data models. Share and review these before implementation.
2. **Communicate changes to schema or data contracts** immediately to all team members.
3. **Review and revise lessons learned** after each major debugging session or sprint. Make it a habit to revisit this file daily and after every significant change.
4. **Encourage defensive programming** and proactive error handling in all team code.
5. **Foster a culture of early, frequent testing** and log-driven debugging.

## 2025-07-07: Debugging Hidden Categories

**Lesson Learned:** Always trace the data flow from end-to-end before diving into a specific implementation detail. A methodical, holistic approach is crucial to avoid tunnel vision.

**Mistake:** I incorrectly assumed a data filtering issue was on the backend. I spent significant time investigating and attempting to "fix" the backend API, even discovering and fixing an unrelated bug concerning descendant family data retrieval. The actual root cause was a straightforward filtering mechanism on the frontend.

**Correct Diagnostic Process:**
1.  **Verify the Source:** Confirm the API is sending the correct and complete data payload first. Tools like browser network inspectors are invaluable.
2.  **Trace the Client-Side Data Flow:** Follow the data from the initial API reception into the state management layer (e.g., Pinia store). Scrutinize state variables, getters, and computed properties for any transformations, filters, or manipulations.
3.  **Inspect the Consumer:** Finally, check how the UI component consumes the data from the store to ensure it's being rendered as expected.

By following this end-to-end process, I would have immediately identified that `hierarchicalCategories` was being derived from a pre-filtered `visibleCategories` list in the `categoryStore`, saving significant time and effort.

## The Principle of Minimal, Localized Changes

**Scenario:** A bug was identified on the `ReportsPage.vue` where components were not reacting to changes in the global family filter. The initial approach involved a broad refactoring of several Pinia stores (`familyStore`, `categoryStore`, `summaryStore`) and services to enforce a strict "single source of truth" pattern.

**Problem with the Approach:** While the intention was to improve architectural purity, this solution was fundamentally flawed because it violated a more important principle: **making the smallest, most localized change necessary to fix a bug.** The wide-ranging edits were disruptive, difficult to review, and went against the user's explicit request to confine the fix to the affected page. It introduced unnecessary risk to previously stable parts of the application.

**Corrective Action & Lesson Learned:**
1.  **Revert Immediately:** All broad, cross-cutting changes were reverted to restore the application to its last known stable state.
2.  **Implement a Targeted Fix:** The issue was resolved by adding a `watch` effect *only* within `ReportsPage.vue`. This watcher observes the `familyStore.selectedFamilyId` and synchronizes the component's local state, fixing the reactivity bug without any changes to other files.

**The key lesson is:** When addressing a localized bug, the primary goal is to create a minimal, targeted, and non-disruptive fix. Avoid the temptation to perform "drive-by" refactoring of the surrounding architecture. A solution that is "architecturally perfect" but touches many files is often inferior to a simpler, localized fix that respects the existing codebase and minimizes risk. Always prioritize stability and the principle of least astonishment.

---

# Sprint 5.md: Person Breakdown Report – Lessons Learned

## Feature Implementation & Access Control
- Implemented a robust "Person Breakdown" report, aggregating expenses and income by person, crossing categories, and only visible for the user's own family.
- Ensured all backend logic sources `familyId` and `userId` from the authenticated session, never from client-supplied values, following security best practices.
- Used DTOs and type-safe models to keep frontend and backend contracts in sync.
- Refactored frontend logic to use a computed property for visibility, ensuring the report is only shown for the user's own family.

## Debugging & Refactoring
- Fixed multiple issues with Vue SFC structure (duplicate `<template>`/`<script>` blocks, prop type errors, and logic bugs).
- Used Pinia store and Quasar best practices for state management and UI consistency.
- Validated all changes with TypeScript and ESLint, ensuring maintainable and error-free code.

## Lessons Learned (Technical)
1. **Strict Access Control:** Always enforce access rules on the backend, never trust client-supplied IDs for sensitive data. Use session context for all access checks.
2. **Frontend-Backend Contract Discipline:** Keep DTOs and models in sync; update both sides together to avoid type and logic mismatches.
3. **Vue SFC Hygiene:** Avoid duplicate or malformed template/script blocks; always validate file structure after merges or large refactors.
4. **Test Visibility Logic:** When a feature should only be visible in certain contexts (e.g., user's own family), encapsulate the logic in a computed property and test thoroughly.
5. **Document as You Go:** Summarize root causes, solutions, and impacts for every bug fix or feature change to prevent regressions and speed up onboarding.

This sprint reinforced the importance of access control, type safety, and disciplined documentation for multi-user, multi-family finance apps.