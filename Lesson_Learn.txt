# Lessons Learned - Sprint 2: Multi-User Synchronization & Cloud Backend

## API Payload Consistency & Layered Data Contracts (Sprint 8+)

### Issue: Unwanted Field in API Payload
- A persistent bug caused the `familyId` field to be sent in the POST body for new categories, even though the UI and dialog code explicitly excluded it.
- Root cause: The frontend API service (`categoryApiService.ts`) forcibly added `familyId` to the POST body, regardless of the dialog's payload, due to `{ ...categoryData, familyId }` in the service function.
- The store always passed `familyId` as a separate argument, so the service layer always injected it into the body.

### Resolution
- The fix was to remove `familyId` from the POST body in the API service, sending only the allowed fields from the dialog/component.
- This aligned the frontend contract with the backend's expectations and eliminated the error.

### Lessons Learned (Technical)
1. **Respect Data Contracts at Each Layer:** UI, store, and API service must all agree on the payload shape. Never inject or mutate fields in the service layer unless explicitly required by the backend contract.
2. **Centralize Payload Shaping:** The component or store should be the single source of truth for what is sent to the backend. The API service should only forward, not transform, unless absolutely necessary.
3. **Trace the Data Flow End-to-End:** When a field appears unexpectedly in the backend, check every layer (component, store, service) for places it might be added or mutated.
4. **Defensive Programming:** Add final defensive checks (e.g., deleting unwanted fields) before sending data, but the best solution is to avoid adding them in the first place.
5. **Test the Actual Network Payload:** Use browser dev tools or logging to inspect the real request body, not just the code.

### Lessons Learned (Process)
1. **Root Cause Analysis:** When a bug persists despite apparent fixes, always check for hidden or duplicated logic in lower layers (services, stores).
2. **Document Data Contracts:** Keep a clear record of what each API expects and what each layer is responsible for.
3. **Review Service Layer Logic:** Service functions should be as thin as possible unless transformation is required by backend design.

## Docker & Containerization:
1.  **Dockerfile Best Practices:**
    *   Pay close attention to `Dockerfile` syntax. Inline comments can sometimes cause parsing issues; prefer comments on their own lines.
    *   The order of `COPY` and `RUN` commands significantly impacts build caching and the final image state. Ensure dependencies (like `prisma/schema.prisma`) are copied *before* `npm install` if postinstall scripts (like `prisma generate`) rely on them.
    *   Multi-stage builds are effective for keeping production images lean by separating build-time dependencies from runtime dependencies.
2.  **Dependency Management in Docker:**
    *   `npm install --only=production` in the final Docker stage is crucial for smaller images but means any runtime-required packages *must* be in `dependencies`, not `devDependencies` (e.g., `@nestjs/swagger`).
3.  **Prisma & Docker:**
    *   `binaryTargets` in `schema.prisma` is essential for cross-platform compatibility (e.g., developing on Windows, deploying on Linux/Alpine). Always include the target runtime (like `linux-musl-openssl-3.0.x` for Alpine).
    *   Ensure `prisma generate` runs within the final image's context, typically via `@prisma/client`'s `postinstall` script, which requires the `schema.prisma` to be present.
4.  **Database Migrations in Docker:**
    *   Database migrations (`npx prisma migrate deploy`) must be explicitly run as part of the container's startup command or entrypoint script in `docker-compose.yml` to ensure the database schema is up-to-date before the application starts.
5.  **Debugging Docker Builds & Runtime:**
    *   Use `docker-compose logs -f <service>` extensively.
    *   For build issues, add `RUN echo "..." && ls -R ...` commands in the `Dockerfile` to inspect the filesystem at various build stages. Invalidate cache for these steps by making minor changes to the `RUN` command.
    *   If a container is crash-looping, temporarily change its `CMD` in the `Dockerfile` (or `command` in `docker-compose.yml`) to something like `sh -c "tail -f /dev/null"` to keep it running for inspection via `docker exec -it <container_name> sh`.

## Backend (NestJS, Prisma, TypeScript):
1.  **TypeScript Path Aliases:**
    *   Path aliases defined in `tsconfig.json` (`paths` and `baseUrl`) are for compile-time.
    *   For runtime resolution in Node.js (especially after compilation to JS), `tsconfig-paths` is necessary.
    *   A separate `tsconfig.prod.json` (or similar) with `baseUrl` pointing to the compiled output directory (e.g., `./dist`) is often required for `tsconfig-paths` to work correctly in production/Docker. `TS_NODE_PROJECT` environment variable should point to this file.
2.  **CORS Configuration:**
    *   Backend (NestJS `app.enableCors()` and `WebSocketGateway` options) must be configured to allow requests from the frontend's origin, including different ports and LAN IPs.
3.  **Environment Variables:**
    *   Use environment variables consistently for configuration (database URLs, frontend URLs, ports, `NODE_ENV`). `docker-compose.yml` is a good place to set these for services.
4.  **WebSocket User Scoping:**
    *   Join clients to user-specific rooms (e.g., based on `userId`) in the `WebSocketGateway` to ensure targeted real-time updates.

## Frontend (Quasar, Pinia, Vite):
1.  **API Base URL Configuration:**
    *   The `VITE_API_BASE_URL` (or similar) used during the frontend build must point to the URL the *browser* will use to access the backend (e.g., `http://<host_lan_ip>:<backend_port>`), not the Docker internal service name.
2.  **State Management & Real-time Updates:**
    *   Pinia stores are effective for managing application state and centralizing API calls.
    *   WebSocket event handlers in stores should update the local state, triggering reactivity in components.
    *   Ensure socket connections and listeners are properly established upon user authentication and cleaned up on logout or component unmount to prevent memory leaks or stale listeners.
3.  **Axios Interceptors:**
    *   Request interceptors are useful for attaching auth tokens.
    *   Response interceptors can handle global errors like 401 Unauthorized (e.g., triggering logout).
4.  **Dev Mode vs. Production Mode:**
    *   Be mindful of how `import.meta.env.DEV` and custom build arguments (like `VITE_FORCE_DEV_USER`) affect application behavior, especially for authentication and API URLs.

## Networking & Docker Compose:
1.  **Service Discovery vs. Host Access:**
    *   Containers on the same Docker Compose network can reach each other using service names (e.g., `backend` can reach `db` at `db:5432`).
    *   The browser (on the host or LAN) accesses services via `localhost:<exposed_port>` or `<host_ip>:<exposed_port>`.
2.  **`depends_on` with `condition: service_healthy`:**
    *   Crucial for ensuring services like the database are ready before dependent services (like the backend) start.

## General Development & Debugging:
1.  **Iterative Problem Solving:** Break down complex issues. The "module not found" errors were tackled one by one, revealing subsequent issues.
2.  **Clear Error Messages:** Pay close attention to error messages. Prisma, NestJS, and Docker often provide very specific clues.
3.  **Version Control:** (Implicit) Regular commits would have been invaluable for rolling back to a stable state if a change introduced too many problems.
4.  **Consistency:** Ensure consistency between DTOs (backend), API service payloads (frontend), and database models/schemas.

## Data Model & State Management Consistency
1.  **Single Source of Truth for IDs:** A seemingly simple display bug (showing a UUID for a name) revealed a systemic data integrity issue. The `payer` field was ambiguously used for both `personId` and `membershipId` across different parts of the application. **Lesson:** Ensure critical identifiers have a single, consistent meaning and type across the entire stack (UI form -> state store -> API payload -> backend service -> database).
2.  **Centralize Data Transformation:** The fix required converting the UI's `membershipId` to the backend's required `personId`. The most robust place for this transformation was not in the component, but in the central state management layer (`transactionStore.ts`). **Lesson:** Centralize data mapping and transformation logic in stores or services to prevent inconsistencies and make the code easier to maintain and debug.
3.  **Regressions Reveal Deeper Issues:** When an initial fix for the `payer` display caused a regression where the `category` also started showing as a UUID, it indicated the problem wasn't just about the `payer` field. It was a flaw in the entire `updateTransaction` data flow. **Lesson:** Pay close attention to regressions; they often point to a more fundamental problem than the one you initially tried to solve.

## Modular Seeder Debugging & Data Integrity (Sprint 7+)

### How much effort could have been saved?
- If the solution (unique key-based mapping, schema alignment, defensive checks, and modular orchestration) had been defined and enforced from the start, we could have saved at least 70-80% of the debugging and rework time.
- Most errors (key mismatches, undefined references, Prisma validation errors) were preventable with clear contracts and up-front schema/data alignment.
- Early, robust logging and defensive programming would have reduced the time spent on root cause analysis.
- A single source of truth for keys and IDs, and validating all seed data before running, would have prevented cascading failures.

### Lessons Learned (Technical)
1. **Define and enforce unique keys** for all entities (categories, memberships, etc.) in both schema and seed data from the beginning.
2. **Align schema and seeders early:** Run migrations and update the database before writing or running seeders that depend on new fields.
3. **Centralize mapping logic:** Build all lookups (e.g., categoryMap, membershipMap) by key, not by id or array index.
4. **Add robust logging and error handling** to all seeders and orchestrators. Log missing keys, undefined references, and data mismatches.
5. **Validate all foreign key references** before using them in upserts. Fail fast and log context if a key is missing.
6. **Test each seeder in isolation** before integrating into the main orchestrator. Use log files to capture runtime state and error context.
7. **Iterate and test frequently,** running the seed process after each change to catch issues early.

### Lessons Learned (Team & Process)
1. **Document contracts and expectations** for all seeders and data models. Share and review these before implementation.
2. **Communicate changes to schema or data contracts** immediately to all team members.
3. **Review and revise lessons learned** after each major debugging session or sprint. Make it a habit to revisit this file daily and after every significant change.
4. **Encourage defensive programming** and proactive error handling in all team code.
5. **Foster a culture of early, frequent testing** and log-driven debugging.

## 2025-07-07: Debugging Hidden Categories

**Lesson Learned:** Always trace the data flow from end-to-end before diving into a specific implementation detail. A methodical, holistic approach is crucial to avoid tunnel vision.

**Mistake:** I incorrectly assumed a data filtering issue was on the backend. I spent significant time investigating and attempting to "fix" the backend API, even discovering and fixing an unrelated bug concerning descendant family data retrieval. The actual root cause was a straightforward filtering mechanism on the frontend.

**Correct Diagnostic Process:**
1.  **Verify the Source:** Confirm the API is sending the correct and complete data payload first. Tools like browser network inspectors are invaluable.
2.  **Trace the Client-Side Data Flow:** Follow the data from the initial API reception into the state management layer (e.g., Pinia store). Scrutinize state variables, getters, and computed properties for any transformations, filters, or manipulations.
3.  **Inspect the Consumer:** Finally, check how the UI component consumes the data from the store to ensure it's being rendered as expected.

By following this end-to-end process, I would have immediately identified that `hierarchicalCategories` was being derived from a pre-filtered `visibleCategories` list in the `categoryStore`, saving significant time and effort.

---
This sprint was a significant leap, and these lessons will be very helpful for future development!